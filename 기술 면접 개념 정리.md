# 기술 면접 개념 정리

> 1. Data Structure
> 2. Network
> 3. Operating System
> 4. Database
> 5. Design Pattern
> 6. Algorithm
> 7. Java
> 8. JavaScript
> 9. Spring
> 10. Security
> 11. ETC

## 1. Data Structure

### 1. stack

> LIFO, pop. push, peek, isEmpty 
>
> - 재귀 알고리즘을 사용할 때 스택이 유용
>
> 재귀적으로 함수를 호출해야 하는 경우 임시 데이터를 스택에 넣어 준다
>
> 재귀 함수를 빠져나와 백트레킹을 할 때 스택에 넣어둔 임시 데이터를 빼줘야 한다
>
> 스택은 이러한 행위를 직관적으로 가능하게 함
>
> 스택은 재귀 알고리즘을 반복적 형태를 통해서 구현할 수 있게 해준다.
>
> - 웹브라우저 방문 기록, 언두, 역순 문자열 만들기 괄표검사, 후위 표기법 계산에 사용

### 2. Queue

> FIFO, add, remove peek, isempty
>
> - 데이터가 입력된 시간 순서대로 처리해야 할 필요가 있는 상황에 이용
>
> - BFS, Cache, 우선순위가 같은 작업 예약, 콜센터 고객대기시간 ,
>
> - > add Exception을 반환 offer는 null이나 false를 리턴

### 3. Graph

> 단순히 노드와 간선을 하나로 모아놓은 자료 구조
>
> > 연결되어 있는 객체 간의 관계를 표현할 수 있는 자료구조
> >
> > 그래프는 여러 개의 고립된 부분 그래프로 구성될 수 있다
>
> 그래프의 특징
>
> > 그래프는 네트워크 모델이다.
> >
> > 2개 이상의 경로가 가능하다
> >
> > 셀프 루프 뿐만 아니라 루프 회로 모두 가능하다
> >
> > 루트 노드의 개념이 없다.
> >
> > 부모자식관계가 없다.
> >
> > 순회는 디에프에스 비에프 에스로 이루어 진다.
> >
> > 간선의 유무는 그래프에 따라 다르다.

### 4. Tree

> 트리의 개념
>
> > 트리는 노드로 이루어진 자료구조
> >
> > > 트리는 하나의 루트 노드를 갖는다.
> > >
> > > 루트 노드는 0개 이상의 자식 노드를 갖고 있다.
> > >
> > > 그 자식 노드 또한 0개 이상의 자식 노드를 갖고 있고, 이는 반복적으로 정의 된다.
> >
> > 노드들과 노드들을 연결하는 간선들로 구성되어 있다.
> >
> > > 트리에는 사이클이 존재할 수 없다.
> > >
> > > 노드들은 특정 순서로 나열될 수도 있고 그럴 수 없을 수도 있따.
> >
> > 계층적 관계를 표현한다.
>
> 트리의 특징
>
> > 그래프의 한 종류이다. '최소연결트리' 라고도 불린다.
> >
> > 트리는 계층 모델이다.
> >
> > 방향성이 있는 비순환 그래프다.
> >
> > 노드가 N개인 트리는 항상 N-1개의 간선을 가진다.
> >
> > 루트에서 어떤 노드로 가는 경로는 유일하다.
> >
> > 한개의 루트 노드만이 존재하며 모든 자식 노드는 한개의 부모 노드만을 가진다.
> >
> > 순회는 Pre-order, In-Order, Post-order
> >
> > 트리는 이진트리 이진 탐색 트리, 균형 트리, 이진 힙 등이 있다.

### 5. 그래프와 트리의 차이점

> |              | 그래프                                                       | 트리                                                         |
> | ------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
> | 정의         | 노드와 그 노드를 연결하는 간선을 하나로 모아놓은 자료구조    | 그래프의 한 종류, 방향성이 있는 비순환 그래프의 한 종류이다. |
> | 방향성       | 방향그래프, 무방향 그래프 모두 존재                          | 방향 그래프                                                  |
> | 사이클       | 사이클 가능<br />자체 간선도 가능<br />순환 그래프, 비순환 그래프 모두 존재 | 사이클 불가능<br />자체 간선도 불가능<br />비순환 그래프     |
> | 루트노드     | 루트노드의 개념이 없음                                       | 한개의 루트노드만이 존재<br />모든 자식 노드는 한개의 부모노드만을 가짐 |
> | 부모-자식    | 부모자식개념이 없음                                          | 부모-자식관계<br />탑바텀 또는 바텀 탑으로 이루어짐          |
> | 모델         | 네트워크 모델                                                | 계층모델                                                     |
> | 순회         | DFS, BFS                                                     | DFS, BFS안의 프리 인 포스트 오더                             |
> | 간선의 수    | 그래프에 따라 간선의 수가 다름<br />간선이 없을 수도 있음    | 노드가 N인 트리는 항상 N-1의 간선을 가짐                     |
> | 경로         | -                                                            | 임의의 두 노드 간의 경로는 유일                              |
> | 예시 및 종류 | 지도, 지하철 노선도의 최단경로, 전기회로의 소자들, 도로,선수과목 | 이진트리, 이진탐색트리, 균형트리, 이진 힙 등                 |
>
> 

### 6. Binary Heap

> 힙이란?
>
> > 완전 이진 트리의 일종으로, 우선순위 큐를 위하여 만들어진 자료구조이다.
> >
> > 여러개의 값들 중에서 최대값이나 최솟값을 빠르게 찾아내도록 만들어진 자료구조이다.
> >
> > 힙은 일종의 반정렬 상태를 유지한다.
> >
> > 힙트리 에서는 중복된 값을 허용한다.  

## 2. Network

### 1. OSI 7 Layer

> OSI 란
>
> > 국제 표준화 기구에서 개발한 모델로, 컴퓨터 네트워크 프로토콜 디자인과 통신을 계층으로 나누어 설명한 것이다
> >
> > 각 계층은 하위 계층의 기능만을 이용하고 상위 계층에게 기능을 제공한다.
> >
> > 프로토콜 스택 혹은 스택은 이러한 계층들로 구선되는 프로토콜 세스템이 구현된 시스템을 가리키는데, 프로토콜 스택은 하드웨어나 소프트웨어 혹은 둘의 혼합으로 구현될 수 있다.
> >
> > 일반적으로 하위 계층들은 하드웨어로, 상위 계층들은 소프트웨어로 구현된다.
>
> 물리계층 : Physical Layer
>
> > 네트워크의 기본 네트워크 하드웨어 전송 기술을 이룬다.
> >
> > 네트워크의 높은 수준의 기능의 논리 데이터 구조를 기초로 하는 필수 계층이다.
> >
> > 전송 단위는 비트이다.
>
> 데이터 링크 계층  : Data Link Layer
>
> > 포인트 투 포인트 간 신뢰성있는 전송을 보장하기 위한 계층으로 CRC기반의 오류 제어와 흐름 제어가 필요하다.
> >
> > 주소 값은 물리적으로 할당 받는데, 이는 네트워크 카드가 만들어 질 때부터 맥 주소가 정해져 있다는 뜻이다. 
> >
> > 데이터 링크 계층의 가장 잘 알려진 예는 이더넷이다.
> >
> > 데이터 전송 단위는 프레임 이다.
>
> 네트워크 계층 : Network layer
>
> > 여러개의 노드를 거칠 때 마다 경로를 찾아주는 역할을 하는 계층으로 다양한 길이의 데이터를 네트워크를 통해 전달하고, 그 과정에서 전송 계층이 요구하는 서비스 품질을 제공하기 위해 기능적, 절차적 수단을 제공한다.
> >
> > 네트워크 계층은 라우팅, 흐름 제어, 세그멘테이션, 오류제어, 인터네트워킹 등을 수행한다.
> >
> > 논리적인 주소 구조 (IP), 곧 네트워크 관리자가 직접 주소를 할당하는 구조를 가지며, 계층적이다.
> >
> > 데이터 전송 단위는 Datagram(Packet)이다.
>
> 전송 계층 : Transport Layer
>
> > 양 끝단의 사용사들의 신뢰성있는 데이터를 주고 받을 수 있도록 해줘, 상위 계층들이 데이터 전달의 유효성이나 효율성을 생각하지 않도록 해준다.
> >
> > 시퀀스 넘버 기반의 오류 제어 방식을 사용한다..
> >
> > 전송 계층은 특정 연결의 유효성을 제어하고, 일부 프로토콜은 상태 개념이 있고, 연결기반이다.(이는 전송 계층의 패킷들의 전송이 유효한지 확인하고 전송 실패한 패킷들을 다시 전송한다는 것을 뜻한다.)
> >
> > 가장 잘 알려진 전송 계층의 예는 TCP이다.
> >
> > 데이터 전송 단위는 Segment이다.
>
> 세션 계층
>
> > 양 끝단의 응용 프로세스가 통신을 관리하기 위한 방법을 제공한다.
> >
> > 동시 송수신 방식, 반 이중 방식, 전이중 방식의 통신과 함께 체크 포인팅과 유휴, 종료, 다시 시작 과정 등을 수행한다.
> >
> > 이 계층은 TCP/IP 세션을 만들고 없애는 책임을 진다.
>
> 표현 계층
>
> > 코드 간의 번역을 담당하여 사용자 시스템에서 데이터의 형식상 차이를 다루는 부담을 응용 계층으로부터 덜어준다.
> >
> > MINE 인코딩이나 암호화 등의 동작이 이 계층에서 이루어진다.
>
> 응용 계층
>
> > 응용 프로세스와 직접 관계하여 일반적인 응용 서비스를 수행한다.
> >
> > 일반적인 응용 서비스는 관련된 응용 프로세스들 사이의 전환을 제공한다.

### 2. TCP와 UDP

- 네트워크 계층 중 전송 계층에서 사용하는 프로토콜

#### TCP

> Transmission Control Protocol

> - 인터넷 상에서 데이터를 메세지의 형태(세그먼트 라는 블록단위)로 보내기 위해 IP와 함께 사용하는 프로토콜이다.
>
> - TCP와 IP를 함께 사용하는데, IP가 데이터의 배달을 처리한다면, TCP는 패킷을 추적 및 관리한다.
>
> - 연결형 서비스로 가상 회선 방식을 사용한다
>
> - > 3-way handshaking과정을 통해 연결을 설정하고, 4-way handshaking을 통해 연결을 해제한다.
>
> - 흐름 제어 및 혼잡 제어를 제공한다.
>
> - > 흐름제어
>   >
>   > > 데이터를 소인하는 곳과 수신하는 곳의 데이터 처리 속도를 조절하여 수신자의 버퍼 오버플로우를 방지하는 것
>   > >
>   > > 송신하는 곳에서 감당이 안되게 많은 데이터를 빠르게 보내 수신하는 곳에서 문제가 일어나는 것을 막는다.
>   >
>   > 혼잡제어
>   >
>   > >네트워크 내의 패킷 수가 넘치게 증가하지 않도록 방지하는 것
>   > >
>   > >정보의 소통량이 과다하면 패킷을 조금만 전송하여 혼잡 붕괴 현상이 일어나는 것을 막는다
>
> - 높은 신뢰성을 보장한다
>
> - UDP보다 속도가 느리다
>
> - 전이중(Full-Duplex), 점대점(Point to Point) 방식이다.
>
> - > 전이중 : 전송이 양방향으로 동시에 일어날 수 있다.
>   >
>   > 점대점 : 각 연결이 정확히 2개의 종단점을 가지고 있다.
>   >
>   > 멀티캐스팅이나 브로드캐스팅을 지원하지 않는다
>
> - 연속성보다 신뢰성 있는 전송이 중요할 때 사용된다.

#### UDP

> - 데이터를 데이터그램 단위로 처리하는 프로토콜이다.
> - 비연결형 서비스로 데이터그램 방식을 제공한다.
> - - 연결을 위해 할당되는 논리적인 경로가 없다.
>   - 그렇기 때문에 각각의 패킷은 다른 경로로 전송되고, 각각의 패킷은 독립적인 관계를 지니게 된다.
>   - 이렇게 데이터를 서로 다른 경로로 독립적으로 처리한다.
> - 정보를 주고 받을 때 정보를 보내거나 받는다는 신호절차를 거치지 않는다.
> - UPD헤더의 CheckSum 필드를 통해 최소한의 오류만 검출한다.
> - 신뢰성이 낮다
> - TCP보다 속도가 빠르다.
> - 신뢰성보다는 연속성이 중요한 서비스, 예를 들면 실시간 서비스(스트리밍)에 사용된다.

- 참고

> UDP와 TCP는 각각 별도의 포트 주소 공간을 관리하므로 같은 포트 번호를 사용해도 무방하다. 즉 두 프로토콜에서 동일한 포트번호를 할당해도 서로 다른 포트로 간주한다.
>
> 또한 같은 모듈(UDP나 TCP) 내에서도 클라이언트 프로그램에서 동시에 여러 커넥션을 확립한 경우에는 서로 다른 포트 번호를 동적으로 할당한다.

### 3. TCP의 3 way handshake, 4 way handshake

> TCP는 장비들 사이에 논리적인 접속을 성립하기 위하여 연결을 설정하여 신뢰성을 보장하는 연결형 서비스이다.
>
> 3-way handshake란
>
> > TCP 통신을 이용하여 데이터를 전송하기 위해 네트워크 연결을 설정하는 과정
> >
> > 양쪽 모두 데이터를 전송할 준비가 되었다는 것을 보장하고, 실제로 데이터 전달이 시작하기 전에 한 쪽이 다른 쪽의 준비가 되었다는 것을 알 수 있도록 한다.
> >
> > 즉, TCP/IP 프로토콜을 이용해서 통신을 하는 응용 프로그램이 데이터를 전송하기 전에 먼저 정확한 전송을 보장하기 위해 상대방 컴퓨터와 사전에 세션을 수립하는 과정을 의미한다.
> 
> 4-way handshake란
> 
TCP의 연결을 해제하는 과정

- tcp관련질문1

q. TCP의 연결 설정 과정과 연결 종료 과정이 단계가 차이가 나는 이뉴는?

a. 클라이언트가 데이터 전송을 마쳤다고 하더라도 서버는 아직 보낼 데이터가 남아있을 수 있기 때문에 일단 FIN에 대한 ACK만 보내고, 데이터를 모두 전송한 후에 자신도 FIN을 보낸다

- '' 2

q. 만약 서버에서 FIN 플래그를 전송하기 전에 전송한 패킷이 라우팅 지연이나 패킷 유실로 인한 재전송 등으로 인해 FIN 패킷보다 늦게 도착하는 상황이 발생하면 어떻게 될까?

a. 이러한 현상에 대비하여 Client는 Server로 FIN플래그를 수신하더라도 일정 시간 동안 세션을 남겨 놓고 잉여 패킷을 기다리는 과정을 거친다. (TIME_WAIT 과정)

- ''3

q. 초기 Sequence Number인 ISN을 0부터 시작하지 않고 난수를 생성해서 설정하는 이유?

a. 커넥션을 맺을 때 사용하는 포트의 유한 범위 내에서 사용하고 시간이 지남에 따라 재사용된다. 따라서 두 통신 호스트가 과거에 사용된 포트 번호 쌍을 사용하는 가능성이 존재한다. 서버 측에서는 패킷의 SYN을 보고 패킷을 구분하게 되는데 난수가 아닌 순차적인 넘버가 전송된다면 이전의 Connection으로 부터 오는 패킷으로 인식할 수 잇다. 이런 문제가 발생할 가능성을 줄기이 귀해서 난수로 ISN을 설정한다.

### 4.HTTP와 HTTPS

> HTTP 프로토콜
>
> 개념
>
> > HyperText Transfer Protocol
> >
> > 웹 상에서 클라이언트와 서버 간에 요청/응답으로 정보를 주고 받을 수 있는 프로토콜
>
> 특징
>
> > 주로 HTML 문서를 주고받는데 쓰인다
> >
> > TCP와 UDP를 사용하며, 80번 포트를 사용한다
> >
> > > 비연결:클라이언트가 요청을 서버에 보내고 서버가 적절한 응답을 클라이언트에 보내면 바로 연결이 끊긴다.
> > >
> > > 무상태: 연결을 끊는 순간 클라이언트와 서버의 통신은 끝나며 상태 정보를 유지하지 않는다.
>
> HTTPS 프로토콜
>
> 개념
>
> > HyperText Transfer Protocol over Secure Socket Layer
> >
> > 웹 통신 프로토콜인 HTTP인 보안이 강화된 버전의 프로토콜
>

> 특징
>
> > HTTPS의 기본 TCP/IP 포트로 443번 포트를 사용한다.
> >
> > HTTPS는 소켓 통신에서 일반 텍스트를 이용하는 대신에, 웹 상에서 정보를 암호화하는 SSL이나 TLS프로토콜을 통해 세션 데이터를 암호화 한다.
> >
> > > TLS 프로토콜은 SSL 프로토콜에서 발전한 것이다.
> > >
> > > 두 프로토콜의 주요 목표는 기밀성, 데이터무결성, ID및디지털인증서를 사용한 인증을 제공하는 것이다.
> > >
> > > 따라서 데이터의 적절한 보호를 보장한다.
> > >
> > > 보호의 수준은 웹 브라우저에서의 구현 정확도와 서버 소프트웨어, 지원하는 암호화 알고리즘에 달려있다.
> > >
> > > 금융 정보나 메일 등 중요한 정보를 주고받는 것은 HTTPS를, 아무나 봐도 상관 없는 페이지는 HTTP를 사용한다.
>
> > HTTPS가 필요한 이유?
> >
> > > 클라이언트인 웹 브라우저가 서버에 HTTP를 통해 웹 페이지나 이미지 정보를 요청하면 서버는 이 요청에 응답하여 요구하는 정보를 제공하게 된다.
> > >
> > > 웹 페이지는 텍스트이고, HTTP를 통해 이런 텍스트 정보를 교환하는 것이다.
> > >
> > > 이때 주고받는 텍스트 정보에 주민등록번호나 비밀번호와 같이 민감한 정보가 포함된 상태에서 네트워크 상에서 중간에 제 3자가 정보를 가로챈다면 보안상 큰 문제가 발생한다.
> > >
> > > 즉 중간에서 정보를 볼 수 없도록 주고받는 정보를 암호화하는 방법은 HTTPS를 사용하는 것이다.
>
> HTTPS의 원리
>
> > 공개키 알고리즘 방식
> >
> > 암호화 복호화를 시킬 수 있는 서로 다른 키(공개키, 개인키)를 이용한 암호화 방법
> >
> > 공개키 : 모두에게 공개, 공개키 저장소에 등록
> >
> > 개인키 : 개인에게만 공개. 클라이언트-서버 구조에서는 서버가 가지고 있는 비공개키
> >
> > 클라이언트 -> 서버
> >
> > 사용자의 데이터를 공개키로 암호화
> >
> > 서버로 전송(데이터를 가로채도 개인키가 없으므로 복호화할 수 없음)
> >
> > 서버의 개인키를 통해 복호화하여 요청 처리
>
> HTTPS의 장단점
>
> > 장점
> >
> > > 네트워크 상에서 열람, 수정이 불가능하므로 안전하다
> >
> > 단점
> >
> > > 암호화하는 과정이 웹 서버에 부하를 준다.
> > >
> > > HTTPS는 설치 및 인증서를 유지하는데 추가 비용이 발생한다.
> > >
> > > HTTP에 비해 느리다
> > >
> > > 인터넷이 끊긴 경우 재인증 시간이 소요된다.
> > >
> > > > HTTP는 비연결형으로 웹 페이지를 보는 중 인터넷 연결이 끊겼다가 다시 연결되어도 페이지를 계속 볼 수 있다.
> > > >
> > > > 그러나 HTTPS는 소켓자체에서 인증을 하기 떄문에 인터넷 연걸이 끊기면 소켓도 끊어져서 다시 HTTPS 인증이 필요하다.

### 5. HTTP 요청 응답 헤더

> HTTP 헤더 내 일반헤더 항목
>
> 요청 및 응답 메세지 모두에서 사용 가능한 일반 목적의 기본적인 헤더 항목
>
> 주요 항목들
>
> > Date: HTTP 메세지를 생성한 일시
> >
> > Connection: 클라이언트와 서버 간 연결에 대한 옵션 설정
> >
> > 캐시 컨트롤
> >
> > 프래그마
> >
> > 트레일러
>
> HTTP 헤더 내 엔터티/개체 헤더 항목
>
> 요청 및 응답메시지 모두에서 사용가능한 엔티티에 대한 설명 헤더

### 6. CORS

> CORS(Cross Origin Resource Sharing)란
>
> > 웹 서버에게 보안 크로스 도메인 데이터 전송을 활성화 하는 cross-domain 접근 제어권을 부여한다.
>
> 배경
>
> > 처음 전송되는 리소스의 도메인과 다른 도메인으로부터 리소스가 요청될 경우 해당 리소스는 cross-origin HTTP 요청에 의해 요청된다.
> >
> > 보안상의 이유로 브라우져들은 스크립트 내에서 초기화 되는 cross-origin HTTP 요청을 제한한다.
> >
> > 예를 들면 XMLHttpRequest는 same-origin정책을 따르기에 이를 사용하는 웹 애플리케이션은 자신과 동일한 도메인으로 HTTP요청을 보내는 것만 가능했다.
> >
> > 웹 애플리케이션을 개선시키기 위해, 개발자들은 브라우저 벤더사들에게 이들을 요청할수 있도록 요청했고 CORS가 생겼다.
>
> 과정
>
> > CORS 요청 시에는 미리 OPTIONS 주소로 서버가 CORS를 허용하는지 물어본다.
> >
> > 이때 Access-Control-Request-Method로 실제로 보내고자 하는 메서드를 알리고
> >
> > Access-Control-Request-Headers로 실제로 보내고자 하는 헤더들을 알린다.
> >
> > Allow 항목들은 Request에 대응되는 것으로 서버가 허용하는 메서드와 헤더를 응답하는데 사용된다.
> >
> > Request랑 Allow가 일치하면 CORS 요청이 이루어진다.

### 7. GET 메서드와 POST 메서드

> HTTP 프로토콜을 이용해서 서버에 데이터를 전달할 때 사용하는 방식
>
> GET 메서드 방식
>
> - 개념
>
> > 정보를 조회하기 위한 메서드
> >
> > 서버에서 어떤 데이터를 가져와서 보여주기 위한 용도의 메서드
> >
> > 가져오는 것
>
> - 사용방법
>
> > URL의 끝에 '?'가 붙고, 요청 정보가 키벨류 형태의 쌍을 이루어 ?뒤에 이어서 붙어 서버로 전송한다.
> >
> > 요청 정보가 여러개일 경우 &로 구분한다.
>
> - 특징
>
> > URL에 요청 정보를 붙여서 전송한다
> >
> > URL에 요청 정보가 이어붙기 때문에 길이 제한이 있어서 대용량의 데이터를 전송하기 어렵다
> >
> > > 한번 요청 시 전송 데이터의 양은 255자로 제한된다.
> >
> > 요청 정보를 사용자가 쉽게 눈으로 확인할 수 있다.
> >
> > > 포스트방식보다 보안상 취약하다
> >
> > HTTP 패킷의 Body는 비어있는 상태로 전송한다.
> >
> > > 즉 Body의 데이터 타입을 표현하는 컨텐트 타입 필드도 HTTP Request Header에 들어가지 않는다.
> >
> > POST 방식보다 빠르다
> >
> > > GET방식은 캐싱을 사용할 수 있어 GET 요청과 그에 대한 응답이 브라우저에 의해 캐쉬된다
>
> - POST 메서드 방식
>
> 개념
>
> > 서버의 값이나 상태를 바꾸기 위한 용도의 메서드
> >
> > 수행하는 것 (Insert, Update, Delete)
>
> 사용 방법
>
> > 요청 정보를 HTTP 패킷의 Body안에 숨겨서 서버로 전송한다
> >
> > Request Header의 Content-Type에 해당 데이터 타입이 표현되며, 전송하고자 하는 데이터 타입을 적어 주어야 한다.
> >
> > > Default: application/octet-stream
> > >
> > > 단순 txt의 경우 : text/plain
> > >
> > > 파일의 경우 : multipart/form-date
>
> 특징
>
> > Body 안에 숨겨서 요청 정보를 전송하기 때문에 대용량의 데이터를 전송하기에 적합하다.
> >
> > 클라이언트 쪽에서 데이터를 인코딩하여 서버로 전송하고 이를 받은 서버쪽이 데이터를 디코딩한다.
> >
> > GET방식보다 보안상 안전하다.

> 질문. 조회하기 위한 용도 POST가 아닌 GET방식을 사용하는 이유?
>
> 대답. 설계 원칙에 따라 GET방식은 서버에게 여러번 요청을 하더라도 동일한 응답이 돌아와야 한다.
>
> 겟 방식은 가져오는 것(SELECT)로 서버의 데이터나 상태를 변경시키지 않아야 한다.
>
> 게시판의 리스트, 게시글 보기 기능
>
> 예외 방문자의 로그 남기기 글을 읽는 회수 증가 등
>
> 포스트 방식은 수행하는 것으로, 서버의 값이나 상태를 바꾸기 위한 용도이다.
>
> 게시판에 글쓰기 기능
>
> 웹에서 모든 리소스는 link할 수 있는 url 를 가지고 있어야 한다.
>
> 어떤 웹페이지를 보고 있을 때 다른 살마에게 그 주소를 주기 위해서 주소창의 URL을 복사해서 줄 수 있어야 한다.
>
> 즉 어떤 웹페이지를 조회할 때 원하는 페이지로 바로 이동하거나 이동시키기 위해서는 해당 링크의 정보가 필요하다
>
> 이때 포스트 방식을 사용할 경우에 값이 바디에 있기 때문에 url만 전달할 수 없으므로 겟 방식을 사용해야 한다. 그러나 글을 저장하는 겨웅에는 url을 제공할 필요가 없기 떄문에 포스트 방식을 사용한다.  

--막간 --

에자일 선언 (Agile Manifesto)

- 애자일 개발 4가지 핵심가치

1. 프로세스와 도구보다는 개인과 상호작용에 더 가치를 둔다.
2. 방대한 문서보다는 실행되는 SW에 더 가치를 둔다.
3. 계약 협상보다는 고객과 협업에 더 가치를 둔다.
4. 계획을 따르기 보다는 변화에 반응하는 것에 더 가치를 둔다.

- 애자일 개발 12가지 실행 지침

1. 유용한 소프트웨어를 빠르고, 지속적으로 제공하여 고객을 만족시킨다.
2. 개발 막바지라도 요구사항 변경을 적극 수용한다.
3. 몇 개월이 아닌 몇 주단위로 실행되는 소프트웨어를 제공한다.
4. 고객과 개발자가 프로젝트 기간에 함께 일한다.
5. 개발에 대한 참여 의지가 확실한 사람들로 팀을 구성하고, 필요한 개발 환경과 지원을 제공하며, 일을 잘 끝낼 수 있도록 신뢰한다.
6. 같은 사무실에서 얼굴을 맞대고 의견을 나눈다.
7. 개발의 진척도를 확인하는 1차 기준은 작동하는 소프트웨어이다.
8. 지속 가능한 개발을 장려하고 일정한 속도로 개발을 진행한다.
9. 기술적 우수성과 좋은 설계에 지속적인 관심을 기울이면 민첩성이 향상된다.
10. 단순화를 추구한다.
11. 최상의 아키텍처, 명확한 요구사항, 최상의 설계는 자기 스스로 주도하는 조직적인 팀으로부터 나온다.
12. 더 효과적인 팀이 될 수 있는 방안을 정기적으로 깊이 고민하고 그에 따라 팀의 행동을 조정한다.

-- 정보처리기사 --

1. GoF(Gang of Four)의 디자인 패턴에서 행위의 패턴에 속하는 것은?

1) builder

2) Visitor

3) Prototype

4) Bridge

GoF 에서는 23개의 디자인 패턴을 3가지 유형으로 분류한다.

3가지 유형

A. Creational Pattern

\- 객체를 생성하는데 관련된 패턴들

\- 객체가 생성되는 과정의 유연성을 높이고 코드의 유지를 쉽게함

B. Structural Pattern

\- 프로그램 구조에 관련된 패턴들

\- 프로그램 내의 자료구조나 인터페이스 구조 등 프로그램의 구조를 설계하는데 사용할 수 있는 패턴들

C. Behavioral Pattern

\- 반복적으로 사용되는 객체들의 상호작용을 패턴화 해놓은 것들

싱글톤 패턴

\> 용도

\> > 시스템 내부에 1개의 인스턴스만 생성하고 싶은 경우

\> > > 컴퓨터 자체를 표현한 클래스

\> > > 현재 시스템 설정을 표현한 글래스

\> 사용 방법

\> > 생성자를 private로 선언하고 해당하는 생성자를 클래스 내부에서만 호출함



4. 객체지향 분석 방법론 중 E-R 다이어그램을 사용하여 객체의 행위를 모델링 하며, 객체 식별, 구조 식별, 주체 정의, 속성 및 관계 정의, 서비스 정의 등의 과정으로 구성되는 것은?

1) Coad와 Yourdon 방법

2) Booch 방법

3) Jacobson 방법

4) Wirfs-Brocks 방법

\- 럼바우 방법 : 가장 일반적으로 사용되는 방법으로 분석 활동을 객체 모델, 동적모델, 기능 모델로 나누어 수행하는 방법

\- 부치 방법: 미시적 개발 프로세스와 거시적 개발 프로세스를 모두 사용하는 분석 방법

\- 제이콥슨 방법 : 유즈캐이스를 강조하여 사용하는 분석 방법

\- 코드와 요단방법 : E-R 다이어그램을 사용하여 개체의 활동들을 데이터 모델링 하는데 초점을 둔 기법

\- 윕스-브룩 방법: 분석과 설계간의 구분이 없고 고객 명세서를 평가해서 설계 작업까지 연속적으로 수행하는 기법



5. 코드 설계에서 일정한 일련번호를 부여하는 방식의 코드는?

1) 연상코드 2)블록코드 3)순차코드 4) 표의 숫자코드

\- 연상코드 : 모델명

\- 블록코드 : ex) 1000-1100 : 총무부 

\- 순차코드 : 1, 2, 3, 4

\- 표의 숫자 코드 : 1260 * 820 같은 애들



7. 자료 사전에서 자료의 생략을 의미하는 기호는?

1) { } 2) * * 3 ) = 4) ( )

자료 사전의 표기법

= : 정의

\+ : 구성

[ ] : 택일

{ } : 반복

( ) : 생략가능

\* *: 설명

9. CASE가 갖고 있는 주요 기능이 아닌 것은?

1) 그래픽 지원 2) 소프트웨어 생명주기 전 단계의 연결 3) 언어 번역 4) 다양한 소프트웨어 개발 모형 지원

답: 3)

컴퓨터 지원 소프트웨어 공학 (CASE)는 컴퓨터 지원 시스템 공학이라고도 하는데, 시스템 개발 방법론들의 자동화를 지원하는 소프트웨어 도구를 제공해 개발자의 반복적인 작업량을 줄이도록 하는 것이다. 또한 CASE도구들은 문서의 생성과 개발 팀 간의 협업을 돕는다. 작업된 내용을 검토하고 수정하기 위해 서로 다른 사람의 파일에 접근하도록 허용해 팀 구성원들은 그들의 작업을 손쉽게 공유할 수 있다. CASE 도구들은 강력한 그래픽 기능이 있으며 PC 기반에서 운영된다. CASE 도구들은 차트와 다이어그램을 자동으로 생성하는 그래픽 기능, 화면과 리포트 생성기, 데이터 사전, 분석과 검사도구, 코드 생성기 , 문서 생성기 등을 제공한다

CASE의 장점

\1. 구조적인 것들을 그대로 활용할 수 있다.

\2. 요구 정보들을 추출하고 분석하는 것을 도와준다.

\3. 원형이나 프로그램의 개발 및 유지가 용이하다.

\4. 개발자들이 반복적인 업무에서 벗어나 창의적 업무에서 몰두하게 해 준다.

\5. 소프트웨어의 점진적 개발이 가능하다.

\6. 소프트웨어의 재활용성을 재고시켜 준다.

\7. 모든 것들이 그림으로 표현되어 있기 때문에 개발자들 간에 정보 시스템의 공유가 쉽다.

14. 럼바우의 객체지향 분석 절차를 가장 바르게 나열한 것은?

1) 객체모형 -> 동적모형 -> 기능모형

럼바우 분석 기법

: 소프트웨어 구성 요소를 그래픽 표기법을 이용하여 모델링

객체 모델링 기법 이라고도 함. 

분석 활동은 객체 모델링, 동적 모델링, 기능 모델링을 통해 이루어짐 

\1. 객체 모델링 

\- 객체 다이어그램

18. 소프트웨어 개발 방법 중 요구사항 분석과 거리가 먼 것은?

1) 비용과 일정에 대한 제약 사항 설정

2) 타당성 조사

3) 요구사항 정의 문서화

4) 설계 명세서 작성

답 : 4)

사용자와 같은 다양한 이혜관계자의 상충할 수도 있는 요구사항을 고려하여 새로운 제품이나 변경된 제품에 부합하는 요구와 조건을 결정하는 것과 같은 업부를 포함한다.

체계적인 요구사항 분석은 요구사항 공학으로도 알려져 있다. 이 밖에도 요구사항 수집, 요구사항 획득, 요구사항 명세와 같은 부정확한 용어들이 이따금씩 사용되기도 한다. 요구사항 분석은 개발 과제의 성공에 결정적이다. 식별된 업무의 필요성과 기회와 관련하여 실행 가능하며, 측정 가능하고, 시험 가능하며 시스템 설계를 위해 충분히 상세한 수준까지 정의되어야 한다.

개념적으로 요구사항 분석은 다음의 세 가지 유형의 행위를 포함한다.

\- 요구 사항의 유도 : 요구사항이 무엇인지 결정하기 위해 고객 및 사용자와 대화하는 작업. 요구사항 수집이라고도 불린다.

\- 요구사항의 분석 : 언급된 요구사항이 불명확하거나 불완전하거나 모호하거나 모순되는지를 결정하고 해결하는 것을 가리킨다.

\- 요구사항의 기록 : 요구사항은 자연 언어 문서, 유스 케이스, 사용자 스토리 또는 공정 명세서와 같은 다양한 형식으로 문서화 되어야 한다.

요구사항 분석은 지루하고 힘든 과정이며, 그동안 많은 섬세하고 심리적인 기술이 관련된다. 새로운 시스템은 환경과 사람들간의 관계를 변경시키므로, 모든 이해관계자를 식별하고, 그들 모두의 요구를 고려하며, 새로운 시스템의 결과를 그들에게 이해시키는 것이 중요하다.

요구사항의 종류

요구사항은 몇 가지 방법으로 분류된다. 아래의 분류는 기술적 관리와 관련한 일반적인 요구사항 분류법이다.

\> 고객 요구사항

\> > 시스템의 목적, 주어진 환경과 제한조건, 변경의 유효성과 적합성의 관점에서 시스템의 기대 사항을 정의하는 사실 및 가정을 서술한 것.

\> 기능 요구사항

\> >기능 요구 사항은 반드시 구등등등.

22. 차수는 노드에서 나오는 숫자. 단말 노드는 리프노드

23. 검증 검사 기법 중 개발자의 장소에서 사용자가 개발자 앞에서 행하는 기법이며, 일반적으로 통제된 환경에서 사용자와 개발자가 함께 확인하면서 수행되는 검사는? 

1) 동치 분할 검사 2) 형상 검사 3) 알파 검사 4) 베타 검사

검증 검사 기법들

검증검사 : 소프트웨어가 사용자의 요구사항을 충족하는 가를 검사

\1. 형상 검사(구성 검토, 감사)

\- 구성요소, 목록, 유지보수를 위한 모든 사항이 표현되었는가를 검사

2) 알파 검사

\- 개발자의 장소에서 사용자가 개발자 앞에서 행하는 검사 기법

\- 통제된 환경, 오류와 사용상 문제점을 사용자와 개발자가 함께 확인하며 기록.

3) 베타 검사

\- 선정된 최종 사용자가 여러명의 사용자 앞에서 행하는 검사기법

\- 실업무를 가지고 사용자가 직접 시험, 제어되지 않은 상태에서 행해짐

\- 발견된 오류와 사용상의 문제점을 주기적으로 개발자에게 보고.

25. 소프트웨어 품질 측정을 위해 개발자 관점에서 고려해야할 항목으로 거리가 먼 것은?

1) 정확성 2) 무결성 3) 사용성 4) 간결성

답 : 4) 간결성

27. 디지털 저작권 관리(DRM)의 기술 요소가 아닌 것은?

1) 크랙 방지 기술

2) 정책 관리 기술

3) 암호화 기술

4) 방화벽 기술

답: 4) 방화벽 기술

29. 인터페이스 구현 검증도구 중 아래에서 설명하는 것은?

\- 서비스 호출, 컴포넌트 재사용 등 다양한 환경을 지원하는 테스트 프레임워크

\- 각 테스트 대상 분산 환경에 데몬을 사용하여 테스트 데싱 프로그램을 통해 테스트를 수행하고, 통합하여 자동화하는 검증 도구

1) xUnit 2) STAF 3) FitNesse 4) RubyNode

답 : 2) STAF

xUnit : Java, C++, .net 등 다양한 언어를 지원하는 단위 테스트 프레임워크이다.

STAF: 서비스 호출 및 컴포넌트 재사용 등 다양한 환경을 지원하는 테스트 프레임워크이다.

FitNesse: 웹 기반 테스트케이스 설계, 실행, 결과 확인 등을 지원하는 테스트 프레임워크이다.

NTAF : Fitnesse의 장점인 협업 기능과 STAF의 장점인 재사용 및 확장성을 통합한 NHN의 테스트 자동화 프레임워크이다.

셀레니움 : 다양한 브라우저 및 개발 언어를 지원하는 웹 어플리케이션 테스트 프레임워크이다.

watir : Ruby를 사용하는 애플리케이션 테스트 프레임워크이다.

31. 소프트웨어 형상 관리의 의미로 적잘한 것은?

1) 비용에 관한 사항을 효율적으로 관리하는 것

2) 개발 과정의 변경 사항을 관리 하는 것

3) 테스트 과정에서 소프트웨어를 통합하는 것

4) 개발 인력을 관리하는 것

답 : 2) 개발 과정의 변경 사항을 관리하는 것33. 외계인 코드에 대한 설명으로 옳은 것은?

1) 프로그램의 로직이 복잡하여 이해하기 어려운 프로그램을 의미한다.

2) 아주 오래되거나 참고문서 또는 개발자가 없어 유지보수 작업이 어려운 프로그램을 의미한다.

3) 오류가 없어 디버깅 과정이 필요 없는 프로그램을 의미한다.

4) 사용자가 직접 작성한 프로그램을 의미한다.37. ISO/IEC 9126의 소프트웨어 품질 특성 중 기능성의 하위 특성으로 옳지 않은 것은?

1) 학습성 2) 적합성 3) 정확성 4) 보안성

답: 1) 학습성38. EAI의 구축 유형으로 옳지 않은 것은?

1) point to point 2) Hub & spoke 3) message bus

4) Tree

답 : 4) Tree

\1. 비지니스 서비스 통합 위한 인프라 EAI/웹서비스

가. EAI와 웹서비스의 개념

EAI : 기업의 내부 및 외부 애플리케이션 사이의 통합을 위해 제공되는 프로세스, 기술 및 툴의 집합

웹서비스 : 펴준 XML 포멧 인터페이스를 통해서 네트워크에서 엑세스 될 수 있는 모듈형 애플리케이션

조직의 내외부 서비스 통합 위한 EAI/웹서비스의 활용

\- 조직 내외부의 관리대상 데이터 및 어플리케이션 관리를 위한 비용 증가 39. 소스코드 품질 분석 도구 중 정적 분석 도구가 아닌 것은?

1) pmd 2) cppcheck 3) valMeter 4) checkstyle

정적 분석 도구 종류 

\- Checkstyle : Java 소스 코드에 대한 코딩룰 분석 프로그램

\- CppCheck : C++/C 소스 코드에 대한 잠재적인 문제를 분석할 수 있는 프로그램

\- PMD : Java로 작성 된 소스코드의 잠재적인 문제를 발견하기 위한 정적 테스팅 도구

-StyleCop : C# 소스코드에 대한 코딩룰을 분석할 수 있으며, Visual Studio 개발 도구와 통합할 수 있음

\- cobertura : 자바 코드의 소스 복잡도 분석 및 취약점을 분석하는 도구

\- cpplint 구글에서 사용하고 있는 C++ 코드 스타일 가이드 준수 감지 도구

\- sonar : Java 로 작성된 소스코드의 잠재적인 문제 발견 및 전반적인 관리를 할 수 있으며, PHP등 추가적인 언어에 대한 사용 서비스 지원40. 반 정규화 유형 중 중복 테이블을 추가하는 방법에 해당하지 않는 것은?

1) 빌드 테이블 추가

2) 집계 테이블 추가

3) 진행 테이블 추가

4) 특정 부분만을 포함하는 테이블 추가

\44. 정규화 과정 두부이걸다줘?45. 데이터 무결성 제약 조건 중 "개체 무결성 제약" 조건에 대한 설명으로 맞는 것은?

1) 릴레이션 내의 튜플들이 각 속성의 도메인에 지정된 값만을 가져야 한다.

2) 기본키에 속해있는 애트리뷰트는 널값이나 중복값을 가질 수가 없다.

3) 릴레이션은 참조할 수 없는 외래키 값을 가질 수 없다.

4) 외래 키 값은 참조 릴레이션의 기본키 값과 동일해야 한다.49. 데이터베이스의 논리적 설계 단계에서 수행하는 작업이 아닌 것은?

1) 레코드 집중의 분석 및 설계

2) 논리적 데이터베이스 구조로 매핑

3) 트랜잭션 인터페이스 설계

4) 스키마의 평가 및 정제51. 병행제어의 로킹 단위에 대한 설명으로 옳지 않은 것은 ?

1) 데이터베이스 파일, 레코드 등은 로킹 단위가 될 수 있다.

2) 로킹 단위가 작아지면 로킹 오버헤드가 감소한다.

3) 로킹 단위가 작아지면 데이터 베이스 공유도가 증가한다.

4) 한꺼번에 로킹 할 수 있는 개체의 크기를 로킹 단위라고 한다.67. 은행가 알고리즘은 교착상태의 해결 방법 중 어떤 기법에 해당하는가?

1) Avoidance

2) Detection

3) Prevention

4) Recovery

답 : 1) Avoidance

Deadlock Avoidance 교착 상태 회피

교착 상태 해결 방안 4 종류

1> 교착 상태 예방

2> 교착 상태 회피

3> 교착 상태 탐지

4> 교착 상태 복구

-교착상태 회피는 데드락이 빠질 가능성이 있는지 없는지 운영체제가 검사하고 빠질 가능성이 없을 경우에만 자원을 할당함으로써 문제 발생을 피하는 방법입니다.

은행원 알고리즘에서 운영체제는 안전상태를 유지할 수 있는 요구만을 수락하고 불안전 상태를 초래할 사용자의 요구는 나중에 만족될 수 있을 때 까지 계속 거절한다.

최소한 고객 한명에게 대출해줄 금액은 항상 은행이 보유하고 있어야 한다.

은행원 알고리즘의 단점

\- 할당할 수 있는 자원의 수가 일정해야 한다.

\- 사용자 수가 일정해야 한다.

\- 항상 불안전 상태를 방지해야 하므로 자원 이용도가 낮습니다.

\- 최대 자원 요구량을 미리 알아야 한다.

\- 프로세스들은 유한한 시간 안에 자원을 반납해야 한다.68. IEEE 802.11 워킹 그룹의 무선 LAN 표준화 현황 중 QoS 강화를 위해 MAC 자원 기능을 채택한 것은?

1) 802.11a

2) 802.11b

3) 802.11g

4) 802.11e

답 : 4) 802.11e

IEEE 802.11은 흔히 무선랜, 와이파이라고 부르는 무선 근거리 통신망을 위한 컴퓨터 무선 네트워크에 사용되는 기술로, IEEE의 LAN/MAN 표준 위원회의 11번째 워킹 그룹에서 개발된 표준 기술을 의미한다.

802.11과 와이파이라는 용어가 번갈아 사용되기도 하지만 와이파이 얼라이언스는 와이파이라는 용어를 다른 집합의 표준으로 정의하고 있다. 802.11과 와이파이는 동의어가 아니다.69. TCP/IP 네트워크에서 IP주소를 MAC 주소로 변환하는 프로토콜은?

1) UDP 2) ARP 2) TCP 4) ICMP

답: 2)

이더넷의 물리적인 주소로서 이더넷 카드의 읽기용 기억장치에 기록되어 있다. 주소 크기는 48비트인데, 미국 전기 전자 학회가 전반부 24비트를 벤더에 할당하면 벤더 측은 후반부 24비트에 대해 세부 할당을 한다.

 오늘날 출시되는 대부분의 하드웨어에서는 MAC 스푸핑을 통해 맥 주소를 바꿀 수 있다.

맥 주소는 하나의 네트웍 내에서 호스트를 식별하기 위한 물리적 주소이므로 전 세계적으로 유일한 번호일 필요는 없으며 해당 네트웍 내에서는 유일한 번호여야 한다.

IP주소는 IP 프로토콜을 사용할 때 IP 프로토콜을 사용하는 모든 장비를 구분해 주기 위해 사용한다. 이 IP주소는 다른 네트웍간에 호스트를 식별하는 논리주소로 사용된다. 이 주소는 고정식으로 사용하거나 DHCP서브에 접속하여 주소를 할당받아 사용하는 경우가 있다.71. 교착 상태 발생의 필요 충분 조건이 아닌 것은?

1) 상호 배제

2) 점유와 대기

3) 환형 대기

4) 선점

답: 4) 선점

교착상태는 아래의 네가지 조건을 모두 동시에 충족할 때 발생한다.

\1. 상호배제 : 한 자원에 대한 여러 프로세스의 동시 접근 불가

\2. 점유와 대기 : 자원을 가지고 있는 상태에서 다른 프로세스가 사용하고 있는 자원의 반납을 기다리는 것

\3. 비선점 : 다른 프로세스의 자원을 강제로 가져올 수 없음

\4. 환형대기 : 각 프로세스가 순환적으로 다음 프로세스가 요구하는 자원을 가지고 있는 것

교착상태 해결 방법

\1. 예방 : 교착상태 발생 조건은 위의 네가지 경우를 모두 만족시켰어야 했다. 교착상태를 해결하기 위해서는 네 가지 조건 중 하나만 해결을 하면 된다.

\2. 회피 : 교착상태의 발생 조건을 없애기 보다는 발생하지 않도록 알고리즘을 적용하는 방법으로, 자원 할당 그래프 알고리즘과 은행원 알고리즘이 있다.

\3. 회복 : 교착상태가 발생하는 것을 아예 막지 않고, 만약 교착상태가 발생하면 발생 이후에 문제를 해결하는 방법

\4. 무시 : 교착상태를 해결할때에도 문맥교환에 의한 오버헤드로 성능 저하가 생긴다. 교착상태에 의한 성능 저하보다 이를 해결할 때 성능 저하가 큰 경우 그냥 무시한다.75. 프로세스 상태의 종류가 아닌 것은?

1) Ready 2) Running 3) Request 4) Exit

답 : 3) Request76. IPv6 주소체계로 거리가 먼 것은 ?

1) Unicast 2) Anycast 3) Broadcast 4) Multicast

답 ) 3. broadCast

IPv6는 현재 사용하고 있는 IP 주소 체계인 IPv4의 주소 부족 문제를 해결하기 위해 개발되었다. 128비트의 긴 주소를 사용하여 주소 부족 문제를 해결할 수 있으며, IPv4에 비해 자료 전송 속도가 빠르다.

\- 인증성, 기밀성, 데이터 무결성의 지원으로 보안 문제를 해결할 수 있다.

\- IPv4와 호환성이 뛰어나다

\- 주소의 확장성, 융통성, 연동성이 뛰어나며 실시간 흐름 제어로 향상된 멀티미디어를 지원한다.

\- Traffic Class, Flow Label을 이용하여 등급별, 서비스별로 패킷을 구분할 수 있어 품질 보장이 용이하다.

IPv6의 구성

\- 16비트씩 8부분 총 128비트로 구성되어 있다.

\- 각 부분을 16진수로 표현하고, 콜론(:)으로 구분한다.

\- IPv6는 다음과 같이 세 가지 주소 체계로 나누어진다.

유니케스트 : 단일 송신자와 단일 송신자 간의 통신 (1:1 통신)

멀티 캐스트 : 단일 송신자와 다중 수신자 간의 통신(1:다 통신)

애니캐스트 : 단일 송신자와 가장 가까이 있는 단일 수신자 간의 통신82. 최대 홉수를 15로 제한한 라우팅 프로토콜은?

1) RIP 2)OSPF 3)Static 4) EIGRP

답 : 1) RIP

RIP :

\- 알고리즘 : 거리값 기반

\- 계산단위 : HOP 단위 경로

\- 정보기록 : 라우팅 테이블

\- 특징 : 홉제한

\- 정보 수집 : 30초 주기

\- 적용 : 소규모

OSPF : 

\- 알고리즘 : 최소링크비용

\- 계산단위 :Area(연속된 망 집합)

\- 정보기록 : LSA

\- 특징 : 다익스트라 알고리즘

\- 정보수집 : 필요시 변경 정보 수집

\- 적용 : 대규모망

BGP : 

\- 알고리즘 : 거리값 기반

\- 계산단위 : AS(관리도메인)

\- 정보기록 : 프리픽스목록

\- 특징 : TCP활용(서브넷 집합)

\- 정보 수집 : 필요시 변경 정보 수집

\- 적용 : 대규모망84. CMM 모델의 레벨로 옳지 않은 것은?

1) 최적단계 2) 관리단계 3) 정의단계 4) 계획단계

답 : 4) 계획단계

CMM 단계

레벨 1 : 초기단계

레벨 2 : 반복 가능한 단계

레벨 3 : 정의된 단계

레벨 4 : 관리된 단계

레벨 5 : 최적화 단계

